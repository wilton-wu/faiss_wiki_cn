## 如何加速搜索？

为加快搜索速度，可以将数据集分割为多个部分。我们在d维空间中定义[Voronoi（沃罗诺伊）单元](./voronoi.md)，每个数据库向量会落入其中一个单元。搜索时，仅需比较查询向量x所在单元及其邻近几个单元中的数据库向量y。

该功能通过`IndexIVFFlat`索引实现。此类索引需要训练阶段，可使用与数据库向量分布相同的任何向量集合进行训练，此处我们直接使用数据库向量本身。

`IndexIVFFlat`还需要另一个量化器索引（quantizer）来分配向量到Voronoi单元。每个单元由质心（centroid）定义，确定向量所属单元即是在质心集合中找到该向量的最近邻。这通常由`IndexFlatL2`类型的索引完成。

搜索方法有两个关键参数：`nlist`（单元总数）和`nprobe`（实际搜索的单元数量）。搜索时间大致与探查单元数量（nprobe）呈线性增长关系，同时包含量化过程带来的固定时间消耗。

### Python实现

```python
nlist = 100
k = 4
quantizer = faiss.IndexFlatL2(d)  # 量化器索引
index = faiss.IndexIVFFlat(quantizer, d, nlist)
assert not index.is_trained
index.train(xb)
assert index.is_trained

index.add(xb)                  # 添加数据集（速度可能稍慢）
D, I = index.search(xq, k)     # 执行搜索
print(I[-5:])                  # 输出最后5个查询的邻近结果
index.nprobe = 10              # 默认探查1个单元，调整为10个
D, I = index.search(xq, k)
print(I[-5:])                  # 输出调整后的搜索结果
```

### 搜索结果分析

当nprobe=1时，查询结果如下：

```
[[ 9900 10500  9831 10808]
 [11055 10812 11321 10260]
 [11353 10164 10719 11013]
 [10571 10203 10793 10952]
 [ 9582 10304  9622  9229]]
```

该结果与暴力搜索（前文所述）相似但不完全一致，原因是部分结果未落在精确的Voronoi单元内。将nprobe增至10后：

```
[[ 9900 10500  9309  9831]
 [11055 10895 10812 11321]
 [11353 11103 10164  9787]
 [10571 10664 10632  9638]
 [ 9628  9554 10036  9582]]
```

此时得到正确结果。需注意完美匹配结果的出现与数据分布特性有关（本例数据在x轴方向具有强相关性）。nprobe参数本质上是搜索精度与速度的调节阀——当nprobe = nlist时，结果将与暴力搜索完全一致（但速度更慢）。
