## 内存占用过高，如何压缩存储？

我们之前看到的`IndexFlatL2`和`IndexIVFFlat`索引都存储完整向量。为了扩展到超大规模数据集，Faiss提供了基于[乘积量化器（product quantizers）](./extras/product-quantizer.md)的有损压缩变体。

向量仍存储在Voronoi单元中，但其尺寸被压缩为可配置的字节数m（d必须是m的整数倍）。该压缩基于[乘积量化器](https://hal.archives-ouvertes.fr/file/index/docid/514462/filename/paper_hal.pdf)，可视为对向量子空间进行的额外量化层。

### Python实现

由于向量并非精确存储，搜索方法返回的距离值也是近似值。

```python
nlist = 100
m = 8  # 子量化器数量
k = 4
quantizer = faiss.IndexFlatL2(d)  # 保持相同

# 8表示每个子向量编码为8位
index = faiss.IndexIVFPQ(quantizer, d, nlist, m, 8)

index.train(xb)
index.add(xb)
D, I = index.search(xb[:5], k) # 完整性检查
print(I)
print(D)
index.nprobe = 10              # 保持与先前实验可比性
D, I = index.search(xq, k)     # 执行搜索
print(I[-5:])
```

### 实验结果

结果输出如下：

```
[[   0  608  220  228]
 [   1 1063  277  617]
 [   2   46  114  304]
 [   3  791  527  316]
 [   4  159  288  393]]

[[ 1.40704751  6.19361687  6.34912491  6.35771513]
 [ 1.49901485  5.66632462  5.94188499  6.29570007]
 [ 1.63260388  6.04126883  6.18447495  6.26815748]
 [ 1.5356375   6.33165455  6.64519501  6.86594009]
 [ 1.46203303  6.5022912   6.62621975  6.63154221]]
```

可观察到最近邻被正确找到（即向量自身ID），但向量与自身的估计距离并非零（尽管显著小于与其他邻居的距离）。这是有损压缩导致的典型现象。

本方案将64个32位浮点数压缩至8字节，实现32倍的压缩率。

真实查询场景下的搜索结果如下：

```
[[ 9432  9649  9900 10287]
 [10229 10403  9829  9740]
 [10847 10824  9787 10089]
 [11268 10935 10260 10571]
 [ 9582 10304  9616  9850]]
```

可与前文`IVFFlat`结果对比。当前结果存在误差，但返回ID集中在10000区间附近，表明搜索结果仍处于正确空间区域。实际情况中自然数据表现更好，因为：

- 均匀分布数据难以有效索引，缺乏可利用的规律性
- 自然数据的语义最近邻通常与无关结果存在显著距离差

### 索引构建简化

由于构建索引可能变得复杂，Faiss提供通过工厂函数快速构建的机制。上述索引可通过以下简写方式创建：

```python
index = faiss.index_factory(d, "IVF100,PQ8")
```

将`PQ8`替换为`Flat`即可获得`IndexFlat`索引。该工厂函数特别适用于需要向量预处理（如PCA降维）的场景，例如预处理降维至32D的工厂字符串为：`"PCA32,IVF100,Flat"`。
